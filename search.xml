<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[策略模式]]></title>
    <url>%2F2019%2F04%2F28%2FstudyNotes001%2F</url>
    <content type="text"><![CDATA[在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。 什么是策略模式(Strategy Pattern)在软件开发过程中常常遇到这样的情况, 实现某一个功能有很多种算法或实现策略, 我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能. 如果将这些算法或者策略抽象出来, 提供一个统一的接口, 不同的算法或者策略有不同的实现类, 这样在程序客户端就可以通过注入不同的实现对象来实现算法或者策略的动态替换, 这种模式的可扩展性和可维护性也更高, 这就是策略模式. 策略模式的定义(Strategy Pattern)策略模式: 定义了算法族,分别封装起来,让它们之间可以相互替换,此模式让算法的变化独立与使用算法的客户.(摘抄于Head First设计模式) 简单理解: 定义了一系列算法,每个算法封装起来,各个算法之间可以互相替换,且算法的变化不会影响到使用算法的客户,属于行为型模式. 使用场景 针对同一类型问题的多种处理方式,仅仅是具体行为有差别时; 需要安全的封装多种同一类型的操作时; 出现同一抽象类有多个字类, 而有需要使用 if-else 或者 switch-case 来选择具体字类时; 例如: 或出现大量 if-else 判断时可以使用策略模式优化代码. 例如电商网站支付方式,一般分为银联,微信,支付宝,可以采用策略模式,每一种方式作为一种支付方式的实现,如果哪一个支付方式发生变化,只需要修改对应的实现即可,不需要修改调用的客户端,如果引入新的支付方式,如:随行付,则只需要增加一个对应的随行付实现类即可,遵循开闭原则. 组成部分(三个角色)1. 抽象策略(Strategy):通常由接口或抽象类实现. 定义了多个具体策略的公共接口, 具体策略中各种不同的算法以不同的方式实现这个接口; Context使用这些接口调用不同实现的算法. 2. 具体策略(ConcreteStrategy):实现了Strategy接口或继承与抽象类, 封装了具体的算法和行为. 3. 环境类(Context):持有一个公共策略接口的引用(Strategy), 直接给客户端调用. 优缺点及重点优点: 每个算法单独封装, 减少算法与算法调用者之间的耦合; 算法可以自由切换; 避免使用多重条件判断; 扩展性良好; 缺点: 策略类会增多. 所有策略类都需要对外暴露. 重点 给对象传入什么样的策略, 就执行什么样的动作. 实现代码说明: 代码来自Head First设计模式中SimUDuck的示例. 代码结构: 抽象策略(Strategy): 12345678/** * 飞行行为 */public interface FlyBehavior &#123; //各种飞行实现 public void fly();&#125; 具体策略(ConcreteStrategy): 123456public class FlyWithWings implements FlyBehavior &#123; @Override public void fly() &#123; System.out.println("I'm flying!"); &#125;&#125; 环境类(Context): 123456789101112131415161718192021222324252627282930313233/** * 鸭子类 */public abstract class Duck &#123; //持有一个公共策略接口的引用 public FlyBehavior flyBehavior; public QuackBehavior quackBehavior; public void swim() &#123; System.out.println("我会游泳..."); &#125; public abstract void display(); public void performFly() &#123; flyBehavior.fly(); &#125; public void performQuack() &#123; quackBehavior.quack(); &#125; //提供set方法， 使鸭子可以动态改变飞行策略 public void setFlyBehavior(FlyBehavior flyBehavior) &#123; this.flyBehavior = flyBehavior; &#125; //提供set方法， 使鸭子可以动态改变叫声策略 public void setQuackBehavior(QuackBehavior quackBehavior) &#123; this.quackBehavior = quackBehavior; &#125;&#125; 12345678910111213141516171819/** * 绿头鸭 */public class MallardDuck extends Duck &#123; @Override public void display() &#123; System.out.println("绿头鸭"); &#125; public MallardDuck() &#123; /*MallardDuck 继承 Duck, 所以具有quackBehavior 和 flyBehavior实例变量 当MallardDuck实例化时， 它的构造器会把继承的quackBehavior， flyBehavior实例变量初始化成Quack，FlyWithWings类型的新实例 */ quackBehavior = new Quack(); flyBehavior = new FlyWithWings(); &#125;&#125; 测试类: 123456789101112131415public static void main(String[] args) &#123; Duck mallard = new MallardDuck(); //飞行 mallard.performFly(); //改变鸭子行为（传入飞行策略） mallard.setFlyBehavior(new FlyRocketPowered()); mallard.performFly(); //叫声 mallard.performQuack(); &#125; 执行结果: I'm flying! I'm flying with a rocket! 呱呱叫 生活中的策略模式(我的猜想)俗话说: 人是铁饭是钢, 一顿不吃饿的慌;吃饭也有策略模式, 你晓得嘛. 人(环境类)饿了要吃饭(抽象策略), 但是吃什么你知道吗? 这时你的大脑就会调集你的毕生功力(经验, 生活经历, 常识等等),来知道有哪些东西是可以吃的,比如鸡腿,面包或粥等等(具体策略,暴露所有策略).大脑选择(动态选择策略)吃其中的一种或多种食物来应对身体的不满. 生活中这样的例子还有很多,网上购物(不同的商品即: 具体策略), 世界那么大, 我想去转转.(转转的方式即: 具体策略)等. 结语: 设计模式来源于生活]]></content>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2019%2F04%2F28%2FstudyNotes002%2F</url>
    <content type="text"><![CDATA[设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 设计模式简介设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。 设计模式的使用最佳的实践设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。 设计模式的类型 六大设计原则1、 开闭原则（Open Close Principle）开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 2、 里氏代换原则（Liskov Substitution Principle）里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 3、 依赖倒转原则（Dependence Inversion Principle）这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 4、 接口隔离原则（Interface Segregation Principle）这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。 5、 迪米特法则，又称最少知道原则（Demeter Principle）最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、 合成复用原则（Composite Reuse Principle）合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承 ##结语接下来, 让我们一起来获取更为强大的技能吧!]]></content>
  </entry>
  <entry>
    <title><![CDATA[【持续更新】Markdown笔记]]></title>
    <url>%2F2019%2F04%2F14%2FmarkdownCommand%2F</url>
    <content type="text"><![CDATA[Markdown 是一个 Web 上使用的文本到HTML的转换工具，可以通过简单、易读易写的文本格式生成结构化的HTML文档。 什么是MarkdownMarkdown 是一个 Web 上使用的文本到HTML的转换工具，可以通过简单、易读易写的文本格式生成结构化的HTML文档。目前 github、Stackoverflow 等网站均支持这种格式。 Markdown的优点最大好处是：快速掌握。 简单，适合所有人群，方便打开，不至于出现低版本word打不开高版本word的文档。 避免软件不同，如对方是wps，看到的word文档效果和你不一样。 方便快速排版，节省时间。 轻松的导出为HTML、PDF格式。 纯文本内容，兼容所有的文本编辑器与文字处理软件。 支持Markdown语法的编辑器有很多，部分网站也支持。 Markdown的工具Mac平台Mou：免费好用，支持实时预览，单文档，左边为编辑的Markdown语言，右边为预览效果。(注:Mac升级到sierra后Mou就不能使用了。据说开发者放弃了更新). MacDown: 与Mou相似,支持macOS Mojave. Web端简书,博客园,掘金 Markdown使用语法注意：所有符号均为英文输入法状态,示例图为:MacDown软件 标题设置 (#方法较方便)第一种方法：在标题文字前加#，一级标题为#，二级标题为##，三级标题为###，以此类推，最多六级，其中一级标题文字最大。 第二种方法：在标题文字下行输入–（符号前不可有空格），可表示二级标题。 在标题文字下行输入==，可表示一级标题。 引用块注释>在一段文字前表示引用,如下: 在一段文字前表示引用 文字*文字*斜体，**文字**加粗，“*”可用“_”代替，也能实现斜体和加粗。 文字间换行：在文字前输入 分割线你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线: 列表无序列表：文字前添加*或+或-和一个空格 有序列表：罗马数字和英文句号和一个空格 代码块和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 \ 和 \ 标签来把代码区块包起来。 要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以,示例如下: 超链接[我的博客](链接) 我的博客 Markdown的使用范围 邮件写作 写文章实现快速排版 印象笔记等软件记录笔记 小结简单总结了Markdown的常用语法,有什么问题欢迎留言.]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
