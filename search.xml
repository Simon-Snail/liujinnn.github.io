<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计模式之单件模式 - Singleton]]></title>
    <url>%2F2019%2F05%2F09%2FstudyNotes004%2F</url>
    <content type="text"><![CDATA[用来创建独一无二的，是能有一个实例的对象的入场券。告诉你一个好消息，单件模式的类图可以说是所有模式的类图中最简单的，事实上，它的类图上只有一个类！但是，可不要兴奋过头，尽管从类设计的视角来说很简单，但是实现上还是会遇到相当多的波折。所以，系好安全带，出发了！ 介绍定义单件模式（Singleton Pattern）：确保一个类只有一个实例，并提供一个全局访问点。 使用场景有些对象其实我们只需要一个，比如：线程池（threadpool），缓存（cache），对话框，处理偏好设置和注册表（registry）的对象，日志对象，充当打印机，显卡等设备的驱动程序的对象。事实上，这类对象只能有一个实例，如果制造出多个实例，就会导致许多问题产生，例如：程序的行为异常，资源使用过量，或者是不一致的结果。 要点优点 单件模式是独一无二的，能够确保程序在任何时刻都只有一个对象； 由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单件模式可以提高系统性能。 缺点 由于单件模式中没有抽象层，因此扩展困难； 职责过重，在一定程度上违背了“但一职责原则”。 实现方式在java中实现单件模式需要注意以下三点： 私有的构造器； 一个静态方法； 一个静态变量。 类图单件模式的实现饿汉式代码实现123456789101112131415161718192021/* * 饿汉式（不能懒加载） * 线程安全 */public class SingleHungry &#123; //提供一个静态的全局变量作为访问该实例的入口 private static SingleHungry instance = new SingleHungry(); /* * 构造器私有 */ private SingleHungry() &#123;&#125; /* * 对外提供静态的方法，用来获取该类的实例 */ public static SingleHungry getInstance() &#123; return instance; &#125;&#125; 要点优点：线程安全；缺点：不能懒加载。 静态内部类（饿汉式的变种）代码实现12345678910111213141516/* * 静态内部类（利用类加载机制） * 线程安全 * 懒加载 */public class SingleInner &#123; private SingleInner() &#123;&#125; private static class SingleInnerHolder&#123; private static SingleInner instance = new SingleInner(); &#125; public static SingleInner getInsstance() &#123; return SingleInnerHolder.instance; &#125;&#125; 要点解决了饿汉式不能懒加载的问题。 懒汉式代码实现123456789101112131415161718192021/* * 懒汉式(懒加载) * 线程不安全 */public class Singlelazy &#123; private static Singlelazy instance = null; /* * 构造器私有 */ private Singlelazy() &#123; System.out.println("构造器被调用了"); &#125; public static Singlelazy getInstance() &#123; if(instance == null) &#123; instance = new Singlelazy(); &#125; return instance; &#125;&#125; 要点优点：可以实现懒加载；缺点：线程不安全。 双重检测（懒汉式的变种）代码实现123456789101112131415161718192021222324252627public class Singlelazy2 &#123; /* * 双重检测(懒加载的变种) * 延迟加载 * 线程安全 */ private static Singlelazy2 instance; /* * 构造器私有 */ private Singlelazy2() &#123; System.out.println("构造器被调用了"); &#125; public static Singlelazy2 getInstance() &#123; if(instance == null) &#123; synchronized (Singlelazy2.class) &#123; if(instance == null) &#123; instance = new Singlelazy2(); &#125; &#125; &#125; return instance; &#125;&#125; 要点解决了懒汉式线程不安全的问题。 枚举实现代码实现12345678910111213141516/* * 枚举类的单例模式 * 不存在出现序列化，反射构建对象的漏洞。不能懒加载。默认线程安全 */public enum SingleEnum &#123; //定义示例化的单例对象 INSTANCE; /* * 对象执行的功能 */ public void getInstance() &#123; &#125;&#125; 总结 单件模式的定义； 单件模式的适用场景； 实现单件模式的三个要点； 五种实现单件模式的方法，及优缺点；结语设计模式源于生活]]></content>
      <tags>
        <tag>v1.0.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA设计模式之观察者模式 - Observer]]></title>
    <url>%2F2019%2F05%2F02%2FstudyNotes003%2F</url>
    <content type="text"><![CDATA[有趣的事情发生时，可千万别错过了！有一个模式可以帮你的对象知悉现况，不会错过该对象感兴趣的事。对象甚至在运行时可决定是否要继续被通知。有了观察者，你将会消息灵通。 介绍观察者模式的定义：在对象之间定义一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知，并自动更新。 简单理解为了方便理解观察者模式，我们以报社为例： 报社的业务是出版报纸； 向某家报社订阅报纸，只要他们有新报纸出版，就会给你送来。只要你是他们的订户，你就会一直收到新报纸。 当你不想再看报纸的时候，取消订阅，他们就不会再送新报纸来。 只要报社还在运营，就会一直有人（或单位） 如果你了解报社的订阅是怎么回事，其实就知道观察者是怎么回事了，只是名称不太一样：出版者改称为“主题”(Subject)或“被观察者”(Observable)，订阅者改称为“观察者”(Observer). 主题 + 观察者 = 观察者模式 主题就是定义中的“一”，观察者为定义中的“多”，当主题有变化时，便会通知它的”订阅者“也就是”观察者“ 使用场景 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。 一个对象必须通知其他对象，而并不知道这些对象是谁。 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。 举例：有一个微信公众号服务，不定时发布一些消息，关注公众号就可以收到推送消息，取消关注就收不到推送消息。 优缺点优点 观察者和被观察者是抽象耦合的; 建立一套触发机制。 缺点 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间; 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 注意事项 JAVA 中已经有了对观察者模式的支持类; 避免循环引用; 如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。 实现类图 实现步骤创建抽象主题 - Subject123456789101112public interface Subject &#123; //观察者订阅服务 public void registerObserver(Observer o); //观察者取消订阅服务 public void removeObserver(Observer o); //主题改变时，会被调用，通知所有观察者 public void notifyObservers(); &#125; 创建抽象观察者 - Observer12345public interface Observer &#123; public void update(float temp, float humidity, float pressure); &#125; 创建具体主题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class WeatherData implements Subject &#123; private ArrayList&lt;Observer&gt; observers; private float temperature; private float humidity; private float pressure; public WeatherData() &#123; observers = new ArrayList&lt;Observer&gt;(); &#125; public void registerObserver(Observer o) &#123; observers.add(o); &#125; public void removeObserver(Observer o) &#123; int i = observers.indexOf(o); if (i &gt;= 0) &#123; observers.remove(i); &#125; &#125; public void notifyObservers() &#123; for (Observer observer : observers) &#123; observer.update(temperature, humidity, pressure); &#125; &#125; public void measurementsChanged() &#123; notifyObservers(); &#125; public void setMeasurements(float temperature, float humidity, float pressure) &#123; this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; measurementsChanged(); &#125;// public float getTemperature() &#123;// return temperature;// &#125;// // public float getHumidity() &#123;// return humidity;// &#125;// // public float getPressure() &#123;// return pressure;// &#125;&#125; 创建一个具体观察者12345678910111213141516171819202122public class CurrentConditionsDisplay implements Observer &#123; private float temperature; private float humidity; private Subject weatherData; public CurrentConditionsDisplay(Subject weatherData) &#123; this.weatherData = weatherData; //订阅 weatherData.registerObserver(this); &#125; public void update(float temperature, float humidity, float pressure) &#123; this.temperature = temperature; this.humidity = humidity; display(); &#125; public void display() &#123; System.out.println("Current conditions: " + temperature + "F degrees and " + humidity + "% humidity"); &#125;&#125; 测试123456789101112131415161718public class WeatherStation &#123; public static void main(String[] args) &#123; //创建主题 WeatherData weatherData = new WeatherData(); //创建观察者并订阅 CurrentConditionsDisplay currentDisplay = new CurrentConditionsDisplay(weatherData);// StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData);// ForecastDisplay forecastDisplay = new ForecastDisplay(weatherData); //通知观察者 weatherData.setMeasurements(80, 65, 30.4f);// weatherData.setMeasurements(82, 70, 29.2f);// weatherData.setMeasurements(78, 90, 29.2f); &#125;&#125; 结语设计模式源于生活]]></content>
      <tags>
        <tag>v1.0.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA设计模式之策略模式 - Strategy]]></title>
    <url>%2F2019%2F04%2F28%2FstudyNotes001%2F</url>
    <content type="text"><![CDATA[在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。 介绍什么是策略模式(Strategy Pattern)在软件开发过程中常常遇到这样的情况, 实现某一个功能有很多种算法或实现策略, 我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能. 如果将这些算法或者策略抽象出来, 提供一个统一的接口, 不同的算法或者策略有不同的实现类, 这样在程序客户端就可以通过注入不同的实现对象来实现算法或者策略的动态替换, 这种模式的可扩展性和可维护性也更高, 这就是策略模式. 策略模式的定义(Strategy Pattern)策略模式: 定义了算法族,分别封装起来,让它们之间可以相互替换,此模式让算法的变化独立与使用算法的客户.(摘抄于Head First设计模式) 简单理解: 定义了一系列算法,每个算法封装起来,各个算法之间可以互相替换,且算法的变化不会影响到使用算法的客户,属于行为型模式. 使用场景 针对同一类型问题的多种处理方式,仅仅是具体行为有差别时; 需要安全的封装多种同一类型的操作时; 出现同一抽象类有多个字类, 而有需要使用 if-else 或者 switch-case 来选择具体字类时; 例如: 或出现大量 if-else 判断时可以使用策略模式优化代码. 例如电商网站支付方式,一般分为银联,微信,支付宝,可以采用策略模式,每一种方式作为一种支付方式的实现,如果哪一个支付方式发生变化,只需要修改对应的实现即可,不需要修改调用的客户端,如果引入新的支付方式,如:随行付,则只需要增加一个对应的随行付实现类即可,遵循开闭原则. 组成部分(三个角色)1. 抽象策略(Strategy):通常由接口或抽象类实现. 定义了多个具体策略的公共接口, 具体策略中各种不同的算法以不同的方式实现这个接口; Context使用这些接口调用不同实现的算法. 2. 具体策略(ConcreteStrategy):实现了Strategy接口或继承与抽象类, 封装了具体的算法和行为. 3. 环境类(Context):持有一个公共策略接口的引用(Strategy), 直接给客户端调用. 优缺点及重点优点: 每个算法单独封装, 减少算法与算法调用者之间的耦合; 算法可以自由切换; 避免使用多重条件判断; 扩展性良好; 缺点: 策略类会增多. 所有策略类都需要对外暴露. 重点 给对象传入什么样的策略, 就执行什么样的动作. 实现类图说明: 代码来自Head First设计模式中SimUDuck的示例. 代码结构: 抽象策略(Strategy): 12345678/** * 飞行行为 */public interface FlyBehavior &#123; //各种飞行实现 public void fly();&#125; 具体策略(ConcreteStrategy): 123456public class FlyWithWings implements FlyBehavior &#123; @Override public void fly() &#123; System.out.println("I'm flying!"); &#125;&#125; 环境类(Context): 123456789101112131415161718192021222324252627282930313233/** * 鸭子类 */public abstract class Duck &#123; //持有一个公共策略接口的引用 public FlyBehavior flyBehavior; public QuackBehavior quackBehavior; public void swim() &#123; System.out.println("我会游泳..."); &#125; public abstract void display(); public void performFly() &#123; flyBehavior.fly(); &#125; public void performQuack() &#123; quackBehavior.quack(); &#125; //提供set方法， 使鸭子可以动态改变飞行策略 public void setFlyBehavior(FlyBehavior flyBehavior) &#123; this.flyBehavior = flyBehavior; &#125; //提供set方法， 使鸭子可以动态改变叫声策略 public void setQuackBehavior(QuackBehavior quackBehavior) &#123; this.quackBehavior = quackBehavior; &#125;&#125; 12345678910111213141516171819/** * 绿头鸭 */public class MallardDuck extends Duck &#123; @Override public void display() &#123; System.out.println("绿头鸭"); &#125; public MallardDuck() &#123; /*MallardDuck 继承 Duck, 所以具有quackBehavior 和 flyBehavior实例变量 当MallardDuck实例化时， 它的构造器会把继承的quackBehavior， flyBehavior实例变量初始化成Quack，FlyWithWings类型的新实例 */ quackBehavior = new Quack(); flyBehavior = new FlyWithWings(); &#125;&#125; 测试类: 123456789101112131415public static void main(String[] args) &#123; Duck mallard = new MallardDuck(); //飞行 mallard.performFly(); //改变鸭子行为（传入飞行策略） mallard.setFlyBehavior(new FlyRocketPowered()); mallard.performFly(); //叫声 mallard.performQuack(); &#125; 执行结果: I'm flying! I'm flying with a rocket! 呱呱叫 生活中的策略模式(我的猜想)俗话说: 人是铁饭是钢, 一顿不吃饿的慌;吃饭也有策略模式, 你晓得嘛. 人(环境类)饿了要吃饭(抽象策略), 但是吃什么你知道吗? 这时你的大脑就会调集你的毕生功力(经验, 生活经历, 常识等等),来知道有哪些东西是可以吃的,比如鸡腿,面包或粥等等(具体策略,暴露所有策略).大脑选择(动态选择策略)吃其中的一种或多种食物来应对身体的不满. 生活中这样的例子还有很多,网上购物(不同的商品即: 具体策略), 世界那么大, 我想去转转.(转转的方式即: 具体策略)等. 结语设计模式源于生活]]></content>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2019%2F04%2F28%2FstudyNotes002%2F</url>
    <content type="text"><![CDATA[设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 设计模式简介设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。 设计模式的使用最佳的实践设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。 设计模式的类型 六大设计原则1、 开闭原则（Open Close Principle）开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 2、 里氏代换原则（Liskov Substitution Principle）里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 3、 依赖倒转原则（Dependence Inversion Principle）这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 4、 接口隔离原则（Interface Segregation Principle）这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。 5、 迪米特法则，又称最少知道原则（Demeter Principle）最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、 合成复用原则（Composite Reuse Principle）合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承 ##结语接下来, 让我们一起来获取更为强大的技能吧!]]></content>
  </entry>
  <entry>
    <title><![CDATA[【持续更新】Markdown笔记]]></title>
    <url>%2F2019%2F04%2F14%2FmarkdownCommand%2F</url>
    <content type="text"><![CDATA[Markdown 是一个 Web 上使用的文本到HTML的转换工具，可以通过简单、易读易写的文本格式生成结构化的HTML文档。 什么是MarkdownMarkdown 是一个 Web 上使用的文本到HTML的转换工具，可以通过简单、易读易写的文本格式生成结构化的HTML文档。目前 github、Stackoverflow 等网站均支持这种格式。 Markdown的优点最大好处是：快速掌握。 简单，适合所有人群，方便打开，不至于出现低版本word打不开高版本word的文档。 避免软件不同，如对方是wps，看到的word文档效果和你不一样。 方便快速排版，节省时间。 轻松的导出为HTML、PDF格式。 纯文本内容，兼容所有的文本编辑器与文字处理软件。 支持Markdown语法的编辑器有很多，部分网站也支持。 Markdown的工具Mac平台Mou：免费好用，支持实时预览，单文档，左边为编辑的Markdown语言，右边为预览效果。(注:Mac升级到sierra后Mou就不能使用了。据说开发者放弃了更新). MacDown: 与Mou相似,支持macOS Mojave. Web端简书,博客园,掘金 Markdown使用语法注意：所有符号均为英文输入法状态,示例图为:MacDown软件 标题设置 (#方法较方便)第一种方法：在标题文字前加#，一级标题为#，二级标题为##，三级标题为###，以此类推，最多六级，其中一级标题文字最大。 第二种方法：在标题文字下行输入–（符号前不可有空格），可表示二级标题。 在标题文字下行输入==，可表示一级标题。 引用块注释>在一段文字前表示引用,如下: 在一段文字前表示引用 文字*文字*斜体，**文字**加粗，“*”可用“_”代替，也能实现斜体和加粗。 文字间换行：在文字前输入 分割线你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线: 列表无序列表：文字前添加*或+或-和一个空格 有序列表：罗马数字和英文句号和一个空格 代码块和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 \ 和 \ 标签来把代码区块包起来。 要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以,示例如下: 超链接[我的博客](链接) 我的博客 Markdown的使用范围 邮件写作 写文章实现快速排版 印象笔记等软件记录笔记 小结简单总结了Markdown的常用语法,有什么问题欢迎留言.]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
