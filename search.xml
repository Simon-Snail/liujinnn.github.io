<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaSE（一）之类与对象]]></title>
    <url>%2F2019%2F05%2F10%2FstudyNotes005%2F</url>
    <content type="text"><![CDATA[在java中经常被提到的两个词是类与对象，实质上可以将类看作是对象的载体，它定义了对象所具有的功能。学习java语言必须要掌握类与对象，这样可以从深层次去理解java这种面向对象语言的开发理念，从而更好的掌握java编程思想与编程方式。 OOP概述Java的编程语言是面向对象的，采用这种语言进行编程称为面向对象编程(Object-Oriented Programming, OOP)。 面向对象的特征抽象(abstract) 抽象是从众多的事物中抽取出共同的、本质性的特征，而舍弃其非本质的特征。例如苹果、香蕉、生梨、葡萄、桃子等，它们共同的特性就是水果。得出水果概念的过程，就是一个抽象的过程。要抽象，就必须进行比较，没有比较就无法找到共同的部分。 共同特征是指那些能把一类事物与他类事物区分开来的特征，这些具有区分作用的特征又称本质特征。因此抽取事物的共同特征就是抽取事物的本质特征，舍弃不同特征。所以抽象的过程也是一个裁剪的过程，不同的、非本质性的特征全部裁剪掉了。所谓的共同特征，是相对的，是指从某一个刻面看是共同的。比如，对于汽车和大米，从买卖的角度看都是商品，都有价格，这是他们的共同的特征，而从其他方面来比较是，他们则是不同的。所以在抽象时，同与不同，决定于从什么角度上来抽象。抽象的角度取决于分析问题的目的。在软件开发过程中，识别稳定的需求、识别核心的需求、识别概念性的需求、设计系统的架构、定义系统中构件之间的接口关系等等都是抽象的过程，都是反应系统的本质特征的过程。抽象的，才是稳定的，才是永恒的。 抽象的反义词是具体。人员往往会说：“你讲的太抽象了，能不能讲的具体一点?”在开发语言中，有抽象类，有具体类，具体类可以继承自抽象类，可以实例化。抽象类可以派生出众多的不同的具体类。所谓：“道生一，一生二，二生三，三生万物”。系统的稳定体现在抽象类，系统的变化体现在具体类。抽象类的层次要高于具体类。系统因抽象而稳定，因抽象而生动。 封装(Encapsulation)封装是面向对象编程的核心思想。将对象的属性和行为封装起来，其载体就是类，类通常对客户隐藏其实现细节，这就是封装的思想。例如：用户使用计算机时，只需要使用手指敲击键盘就可以实现一些功能，无需知道计算机内部是如何工作的，即使可能知道计算机的工作原理，但在使用计算机的时候也并不完全依赖计算机工作原理这些细节。 采用封装的思想保证了类内部数据结构的完整性，应用该类的用户不能轻易地直接操作此数据结构，只能执行类允许公开的数据。这样避免了外部操作对内部数据的影响，提高了程序的可维护性。 继承(inheritance)当处理一个问题时，可以将一些有用的类保留下来，在遇到同样问题时拿来复用。例如：我们通过抽象创建一个鸟类，这个类包含所有鸟都有的一些特征，比如：都有嘴，眼睛，或翅膀… …，并且有一些共有的行为，如：都会吃东西，会飞… …，现在需要创建一个信鸽来完成送信的行为，信鸽也属于鸟类，拥有鸟的一些共有特征，眼睛，会飞之类的。这时我们就可以通过信鸽类继承鸟类的方式，来获取共有的这些属性和行为而不需要在信鸽类中重新定义那些共有的属性和行为（眼睛，会飞… …），但并不是所有的鸟都会送信，所以我们在信鸽类中再添加一些信鸽具有的独特的属性和行为。信鸽类保留了鸟类的属性和行为，这样就节省了定义鸟和鸽子共同具有的属性和行为的时间，这就是继承的基本思想。 继承可以复用已有代码，缩短开发时间，提高效率，减少系统在使用过程中出现错误的几率。 新类继承了原始类后,新类就继承了原始类的特性，新类称为原始类的派生类(子类)，而原始类称为新类的基类(父类)，并且派生类(子类)中可以修改或增加新的方法使之更适合特殊的需要。 多态(polymorphism)所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。 以图形类（父类）为例来说明多态，每个图形都有绘画自己的能力，这个能力可以看作是该类具有的行为，如果将子类的对象统一看作是父类的实例对象，这样在绘制图形时，简单地调用父类也就是图形类绘制图形的方法即可绘制任何图形，这就是多态最基本的思想。如下： 图形类 a = new 长方形； 图形类 b = new 正方形； 图形类 c = new 三角形； 我们只是通过图形类这一个父类就能够引用不同的子类，这就是多态——我们只有在运行的时候才会知道引用变量所指向的具体实例对象。 类与对象和对象与引用的关系类与对象的关系类是一种抽象的数据类型,它是对某一类事物整体描述/定义,但是并不能代表某一个具体的事物. 例如:我们生活中所说的词语:动物、植物、手机、电脑等等，这些也都是抽象的概念,而不是指的某一个具体的东西。 例如: Person类、Room类、Car类等，这些类都是用来描述/定义某一类具体的事物应该具备的特点和行为 对象是抽象概念（类）的具体实例 例如：长方形，正方形，三角形就是图形类的一个具体实例，信鸽就是鸟类的具体实例，展现出功能的是具体的实例，而不是一个抽象的概念。 对象与引用的关系引用&quot;指向&quot;对象 java号称一切皆为对象，但java中数据类型有基本数据类型和引用数据类型，基本数据类型暂时不谈，java中的对象都是引用数据类型。在程序中,创建出对象后,直接使用并不方便,所以一般会用一个引用类型的变量去接收这个对象,这个就是所说的引用指向对象. 图形类 a = new 长方形； 图形类 b = new 正方形； = 后面的分别指创建对象，而a,b其实只是引用，并不存储对象而是指向对象。但我们通常都会忽略这一点，称对象a,对象b。 引用只是存储了对象的地址而已，通过地址找到后面的对象； 创建与初始化对象使用new关键字创建的时候,除了分配内存空间之外,还会给创建好的对象进行默认的初始化以及对类中构造器的调用 那么对main方法中的以下代码: Student s = new Student(); 为对象分配内存空间,将对象的实例变量自动初始化默认值为0/false/null。(实例变量的隐式赋值) 如果代码中实例变量有显式赋值,那么就将之前的默认值覆盖掉。(之后可以通过例子看到这个现象)例如:显式赋值private String name = “tom”; 调用构造器; 对象内存地址值赋值给变量。(=号赋值操作) 构造器类中的构造器也称为构造方法,是在进行创建对象的时候必须要调用的。 构造器有以下两个特点: 必须和类的名字相同； 必须没有返回类型,也不能写void。 构造器的作用: 用new创建对象的时候必须使用类的构造器； 造器中的代码执行后,可以给对象中的属性初始化赋值。 构造器重载: 除了无参构造器之外,很多时候我们还会使用有参构造器,在创建对象时候可以给属性赋值. 12345678public class Student&#123; private String name; public Student(String name)&#123; his.name = name; &#125;&#125; 构造器之间的调用: 使用this关键字,在一个构造器中可以调用另一个构造器的代码。 注意:this的这种用法不会产生新的对象,只是调用了构造器中的代码而已.一般情况下只有使用new关键字才会创建新对象。 123456789101112public class Student&#123; private String name; public Student()&#123; this(); &#125; public Student(String name)&#123; this.name = name; &#125;&#125; 默认构造器: 在java中,即使我们在编写类的时候没有写构造器,那么在编译之后也会自动的添加一个无参构造器,这个无参构造器也被称为默认的构造器。 例如： public class Student{ } main: //编译通过,因为有无参构造器 Student s = new Student(); 但是,如果我们手动的编写了一个构造器,那么编译后就不会添加任何构造器了 例如： 123public Student(String name)&#123; this.name = name; &#125; main: //编译失败,因为没有无参构造器 Student s = new Student();]]></content>
  </entry>
  <entry>
    <title><![CDATA[JAVA设计模式之单例模式 - Singleton]]></title>
    <url>%2F2019%2F05%2F09%2FstudyNotes004%2F</url>
    <content type="text"><![CDATA[用来创建独一无二的，是能有一个实例的对象的入场券。告诉你一个好消息，单例模式的类图可以说是所有模式的类图中最简单的，事实上，它的类图上只有一个类！但是，可不要兴奋过头，尽管从类设计的视角来说很简单，但是实现上还是会遇到相当多的波折。所以，系好安全带，出发了！ 介绍定义单例模式（Singleton Pattern）：确保一个类只有一个实例，并提供一个全局访问点。 常用情景有些对象其实我们只需要一个，比如：windows的任务管理器，项目中的读取配置文件的对象，数据库连接池，spring中的bean默认也是单例，线程池（threadpool），缓存（cache），对话框，处理偏好设置和注册表（registry）的对象，日志对象，充当打印机，显卡等设备的驱动程序的对象。事实上，这类对象只能有一个实例，如果制造出多个实例，就会导致许多问题产生，例如：程序的行为异常，资源使用过量，或者是不一致的结果。 要点优点 单例模式存在一个全局访问点，所以优化共享资源； 只生成一个实例，减少了开销，对于一些需要频繁创建和销毁的对象，单例模式可以提高系统性能。 缺点 由于单例模式中没有抽象层，因此扩展困难； 职责过重，在一定程度上违背了“但一职责原则”。 类图在java中实现单例模式需要注意以下三点： 私有的构造器； 一个静态方法； 一个静态变量。 单例模式的实现饿汉式代码实现123456789101112131415161718192021/** 通过饿汉式创建单例模式 * 当前类只能创建一个对象 * 天然线程安全（类只要被加载，就会被加载到全局变量中。所以饿汉式就是及时加载，不能实现懒加载） */public class SingleHungry &#123; //提供一个静态的全局变量作为访问该实例的入口 private static SingleHungry instance = new SingleHungry(); /** * 构造器私有，不让外部通过new创建实例 */ private SingleHungry() &#123;&#125; /** * 对外提供静态的方法，用来获取该类的实例 */ public static SingleHungry getInstance() &#123; return instance; &#125;&#125; 要点优点：线程安全；缺点：不能懒加载。 懒汉式代码实现1234567891011121314151617181920212223242526272829/** * 懒汉式，完成单例模式： * 静态的全局变量，初始化放在了静态方法中，延迟产生了实例 * 延迟加载 * 线程不安全 */public class Singlelazy &#123; //提供一个静态的全局变量作为访问该实例的入口，但不立即加载 private static Singlelazy instance = null; /** * 构造器私有 */ private Singlelazy() &#123; System.out.println("构造器被调用了"); &#125; /** * 提供方法获取该类的实例 * @return */ public static Singlelazy getInstance() &#123; //先查看是否存在对象，不存在则创建 if(instance == null) &#123; instance = new Singlelazy(); &#125; return instance; &#125;&#125; 以上代码存在的问题如图：这段代码是线程不安全的，当有多个线程同时访问该代码时，会出现创建多个实例的情况。为了方便理解，我以Head First设计模式中的图来介绍：以上模拟了多线程问题的运行步骤，只是对象的名称不一样而已，相信对你来说是没问题的。 解决思路1： 加锁。锁方法问题：可以解决问题，但锁住整个方法的粒度太大了，效率较低。不推荐使用 解决思路2： 加锁。锁代码块，先判断后锁问题：不能解决问题，以上方式锁的粒度变小了，但是并不能产生一个实例。原因：多个线程判断之后全局变量都是null，进入后都开始等锁。线程1出去，线程2进来继续实例化，所以得到的对象是多个。 解决思路3: 加锁。锁代码块，先锁后判断。 以上方式解决了问题，当有多个线程同时访问getInstance()。保证了多个线程是以流式，次序性的进入当前方法来获取该类的实例。那么效率一样很低。而且多个线程同时等待。 上面的解决方法似乎都不怎么好，那么有没有一种更好的方法来解决懒汉式的多线程安全问题呢？请继续探索… … 双重检测（双重校验锁）代码实现123456789101112131415161718192021222324252627public class Singlelazy &#123; /* * 双重检测(双重校验锁) * 延迟加载 * 线程安全 */ private static volatile Singlelazy instance; /* * 构造器私有 */ private Singlelazy() &#123; System.out.println("构造器被调用了"); &#125; public static Singlelazy getInstance() &#123; if(instance == null) &#123; synchronized (Singlelazy.class) &#123; if(instance == null) &#123; instance = new Singlelazy(); &#125; &#125; &#125; return instance; &#125;&#125; 要点volatile关键字确保：当instance变量被初始化成Singleton实例时，多个线程正确地处理instance变量。 值得注意的是：很不幸地，在jdk1.5之前的版本，许多JVM对于volatile关键字的实现会导致dcl（double check locking）失效。如果你不能使用jdk1.4之后的版本，就请不要利用此技巧实现单例模式。 双重检测很好的解决了懒汉式多线程安全问题，可以和之前的几种解决思路对比一下，思考一下优点在哪里！ 解决思路: 我们知道为了解决这个线程安全问题，必须加锁，并且必须先锁后判断，思路3已经解决了问题，为了进一步优化代码执行效率，我们再来改进一下代码：我们在锁的外面再加一层对全局变量的判断，这么做的效果是什么呢？当有多个线程来访问时，例如： 线程1，线程2同时进入该方法； 经过最外面的判断后，发现还没有创建实例，这时就会依次执行锁里的逻辑，并创建了实例； 假如这时线程3进入该方法，执行最外面的判断，发现已经创建了实例，这时候直接返回就可以了，并不需要等锁。 静态内部类（饿汉式的变种）代码实现12345678910111213141516/* * 静态内部类创建单例（利用类加载机制，保证线程安全问题） * 线程安全 * 懒加载 */public class SingleInner &#123; private SingleInner() &#123;&#125; private static class SingleInnerHolder&#123; private static SingleInner instance = new SingleInner(); &#125; public static SingleInner getInsstance() &#123; return SingleInnerHolder.instance; &#125;&#125; 要点和饿汉式一样采用的是classLoader机制，保证了线程安全问题，但不同的是，静态内部类同样满足懒加载（当调用getInsstance()方法时，实例才会被创建）。 枚举实现代码实现123456789101112public enum SingleEnum &#123; //定义示例化的单例对象 INSTANCE; /* * 对象执行的功能 */ public void getInstance() &#123; &#125;&#125; 要点枚举类的单例模式，不存在出现序列化，反射构建对象的漏洞（前面几种单例实现方式都存在此问题）。不能懒加载。默认情况枚举实例的创建都是线程安全，但是实例对象实现的方法，需要自己保证线程安全问题。 反射，序列化与单例的关系反射我们以饿汉式为例，如下图：通过反射获取的s3和通过饿汉式获取的s1,s2，并不是同一个实例，那么有什么办法可以解决反射对单例的影响呢！请看下面： 解决方法： 我们通过改变饿汉式构造方法的方式，来解决这个问题：调用时抛出异常： 序列化依旧以饿汉式为例，如下图： 通过序列化，反序列化获取的s3和通过饿汉式获取的s1,s2，并不是同一个实例，那么有什么办法可以解决序列化，反序列化对单例的影响呢！请看下面： 通过在饿汉式中加入此方法，就可以解决这个问题： 创建的构建单例模式的方式比较 饿汉式 效率较高 不能懒加载 线程安全 调用率高 懒汉式 效率较低 懒加载 线程不安全 双重检测（双重校验锁）懒汉式的一个变种 效率较高 懒加载 线程安全 静态内部类 饿汉式的变种 效率较高 懒加载 线程安全 枚举 效率较高 线程安全 不能懒加载 用法总结 懒汉式效率最低； 占用资源较少 不需要懒加载 枚举优先 饿汉式； 占用资源较多 需要懒加载 静态内部类优先 懒汉式（优先使用DCL）。结语设计模式源于生活]]></content>
      <tags>
        <tag>v1.0.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA设计模式之观察者模式 - Observer]]></title>
    <url>%2F2019%2F05%2F02%2FstudyNotes003%2F</url>
    <content type="text"><![CDATA[有趣的事情发生时，可千万别错过了！有一个模式可以帮你的对象知悉现况，不会错过该对象感兴趣的事。对象甚至在运行时可决定是否要继续被通知。有了观察者，你将会消息灵通。 介绍观察者模式的定义：在对象之间定义一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知，并自动更新。 简单理解为了方便理解观察者模式，我们以报社为例： 报社的业务是出版报纸； 向某家报社订阅报纸，只要他们有新报纸出版，就会给你送来。只要你是他们的订户，你就会一直收到新报纸。 当你不想再看报纸的时候，取消订阅，他们就不会再送新报纸来。 只要报社还在运营，就会一直有人（或单位） 如果你了解报社的订阅是怎么回事，其实就知道观察者是怎么回事了，只是名称不太一样：出版者改称为“主题”(Subject)或“被观察者”(Observable)，订阅者改称为“观察者”(Observer). 主题 + 观察者 = 观察者模式 主题就是定义中的“一”，观察者为定义中的“多”，当主题有变化时，便会通知它的”订阅者“也就是”观察者“ 使用场景 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。 一个对象必须通知其他对象，而并不知道这些对象是谁。 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。 举例：有一个微信公众号服务，不定时发布一些消息，关注公众号就可以收到推送消息，取消关注就收不到推送消息。 优缺点优点 观察者和被观察者是抽象耦合的; 建立一套触发机制。 缺点 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间; 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 注意事项 JAVA 中已经有了对观察者模式的支持类; 避免循环引用; 如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。 实现类图 实现步骤创建抽象主题 - Subject123456789101112public interface Subject &#123; //观察者订阅服务 public void registerObserver(Observer o); //观察者取消订阅服务 public void removeObserver(Observer o); //主题改变时，会被调用，通知所有观察者 public void notifyObservers(); &#125; 创建抽象观察者 - Observer12345public interface Observer &#123; public void update(float temp, float humidity, float pressure); &#125; 创建具体主题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class WeatherData implements Subject &#123; private ArrayList&lt;Observer&gt; observers; private float temperature; private float humidity; private float pressure; public WeatherData() &#123; observers = new ArrayList&lt;Observer&gt;(); &#125; public void registerObserver(Observer o) &#123; observers.add(o); &#125; public void removeObserver(Observer o) &#123; int i = observers.indexOf(o); if (i &gt;= 0) &#123; observers.remove(i); &#125; &#125; public void notifyObservers() &#123; for (Observer observer : observers) &#123; observer.update(temperature, humidity, pressure); &#125; &#125; public void measurementsChanged() &#123; notifyObservers(); &#125; public void setMeasurements(float temperature, float humidity, float pressure) &#123; this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; measurementsChanged(); &#125;// public float getTemperature() &#123;// return temperature;// &#125;// // public float getHumidity() &#123;// return humidity;// &#125;// // public float getPressure() &#123;// return pressure;// &#125;&#125; 创建一个具体观察者12345678910111213141516171819202122public class CurrentConditionsDisplay implements Observer &#123; private float temperature; private float humidity; private Subject weatherData; public CurrentConditionsDisplay(Subject weatherData) &#123; this.weatherData = weatherData; //订阅 weatherData.registerObserver(this); &#125; public void update(float temperature, float humidity, float pressure) &#123; this.temperature = temperature; this.humidity = humidity; display(); &#125; public void display() &#123; System.out.println("Current conditions: " + temperature + "F degrees and " + humidity + "% humidity"); &#125;&#125; 测试123456789101112131415161718public class WeatherStation &#123; public static void main(String[] args) &#123; //创建主题 WeatherData weatherData = new WeatherData(); //创建观察者并订阅 CurrentConditionsDisplay currentDisplay = new CurrentConditionsDisplay(weatherData);// StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData);// ForecastDisplay forecastDisplay = new ForecastDisplay(weatherData); //通知观察者 weatherData.setMeasurements(80, 65, 30.4f);// weatherData.setMeasurements(82, 70, 29.2f);// weatherData.setMeasurements(78, 90, 29.2f); &#125;&#125; 结语设计模式源于生活]]></content>
      <tags>
        <tag>v1.0.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA设计模式之策略模式 - Strategy]]></title>
    <url>%2F2019%2F04%2F28%2FstudyNotes001%2F</url>
    <content type="text"><![CDATA[在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。 介绍什么是策略模式(Strategy Pattern)在软件开发过程中常常遇到这样的情况, 实现某一个功能有很多种算法或实现策略, 我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能. 如果将这些算法或者策略抽象出来, 提供一个统一的接口, 不同的算法或者策略有不同的实现类, 这样在程序客户端就可以通过注入不同的实现对象来实现算法或者策略的动态替换, 这种模式的可扩展性和可维护性也更高, 这就是策略模式. 策略模式的定义(Strategy Pattern)策略模式: 定义了算法族,分别封装起来,让它们之间可以相互替换,此模式让算法的变化独立与使用算法的客户.(摘抄于Head First设计模式) 简单理解: 定义了一系列算法,每个算法封装起来,各个算法之间可以互相替换,且算法的变化不会影响到使用算法的客户,属于行为型模式. 使用场景 针对同一类型问题的多种处理方式,仅仅是具体行为有差别时; 需要安全的封装多种同一类型的操作时; 出现同一抽象类有多个字类, 而有需要使用 if-else 或者 switch-case 来选择具体字类时; 例如: 或出现大量 if-else 判断时可以使用策略模式优化代码. 例如电商网站支付方式,一般分为银联,微信,支付宝,可以采用策略模式,每一种方式作为一种支付方式的实现,如果哪一个支付方式发生变化,只需要修改对应的实现即可,不需要修改调用的客户端,如果引入新的支付方式,如:随行付,则只需要增加一个对应的随行付实现类即可,遵循开闭原则. 组成部分(三个角色)1. 抽象策略(Strategy):通常由接口或抽象类实现. 定义了多个具体策略的公共接口, 具体策略中各种不同的算法以不同的方式实现这个接口; Context使用这些接口调用不同实现的算法. 2. 具体策略(ConcreteStrategy):实现了Strategy接口或继承与抽象类, 封装了具体的算法和行为. 3. 环境类(Context):持有一个公共策略接口的引用(Strategy), 直接给客户端调用. 优缺点及重点优点: 每个算法单独封装, 减少算法与算法调用者之间的耦合; 算法可以自由切换; 避免使用多重条件判断; 扩展性良好; 缺点: 策略类会增多. 所有策略类都需要对外暴露. 重点 给对象传入什么样的策略, 就执行什么样的动作. 实现类图说明: 代码来自Head First设计模式中SimUDuck的示例. 代码结构: 抽象策略(Strategy): 12345678/** * 飞行行为 */public interface FlyBehavior &#123; //各种飞行实现 public void fly();&#125; 具体策略(ConcreteStrategy): 123456public class FlyWithWings implements FlyBehavior &#123; @Override public void fly() &#123; System.out.println("I'm flying!"); &#125;&#125; 环境类(Context): 123456789101112131415161718192021222324252627282930313233/** * 鸭子类 */public abstract class Duck &#123; //持有一个公共策略接口的引用 public FlyBehavior flyBehavior; public QuackBehavior quackBehavior; public void swim() &#123; System.out.println("我会游泳..."); &#125; public abstract void display(); public void performFly() &#123; flyBehavior.fly(); &#125; public void performQuack() &#123; quackBehavior.quack(); &#125; //提供set方法， 使鸭子可以动态改变飞行策略 public void setFlyBehavior(FlyBehavior flyBehavior) &#123; this.flyBehavior = flyBehavior; &#125; //提供set方法， 使鸭子可以动态改变叫声策略 public void setQuackBehavior(QuackBehavior quackBehavior) &#123; this.quackBehavior = quackBehavior; &#125;&#125; 12345678910111213141516171819/** * 绿头鸭 */public class MallardDuck extends Duck &#123; @Override public void display() &#123; System.out.println("绿头鸭"); &#125; public MallardDuck() &#123; /*MallardDuck 继承 Duck, 所以具有quackBehavior 和 flyBehavior实例变量 当MallardDuck实例化时， 它的构造器会把继承的quackBehavior， flyBehavior实例变量初始化成Quack，FlyWithWings类型的新实例 */ quackBehavior = new Quack(); flyBehavior = new FlyWithWings(); &#125;&#125; 测试类: 123456789101112131415public static void main(String[] args) &#123; Duck mallard = new MallardDuck(); //飞行 mallard.performFly(); //改变鸭子行为（传入飞行策略） mallard.setFlyBehavior(new FlyRocketPowered()); mallard.performFly(); //叫声 mallard.performQuack(); &#125; 执行结果: I'm flying! I'm flying with a rocket! 呱呱叫 生活中的策略模式(我的猜想)俗话说: 人是铁饭是钢, 一顿不吃饿的慌;吃饭也有策略模式, 你晓得嘛. 人(环境类)饿了要吃饭(抽象策略), 但是吃什么你知道吗? 这时你的大脑就会调集你的毕生功力(经验, 生活经历, 常识等等),来知道有哪些东西是可以吃的,比如鸡腿,面包或粥等等(具体策略,暴露所有策略).大脑选择(动态选择策略)吃其中的一种或多种食物来应对身体的不满. 生活中这样的例子还有很多,网上购物(不同的商品即: 具体策略), 世界那么大, 我想去转转.(转转的方式即: 具体策略)等. 结语设计模式源于生活]]></content>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2019%2F04%2F28%2FstudyNotes002%2F</url>
    <content type="text"><![CDATA[设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 设计模式简介设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。 设计模式的使用最佳的实践设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。 设计模式的类型 六大设计原则1、 开闭原则（Open Close Principle）开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 2、 里氏代换原则（Liskov Substitution Principle）里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 3、 依赖倒转原则（Dependence Inversion Principle）这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 4、 接口隔离原则（Interface Segregation Principle）这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。 5、 迪米特法则，又称最少知道原则（Demeter Principle）最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、 合成复用原则（Composite Reuse Principle）合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承 ##结语接下来, 让我们一起来获取更为强大的技能吧!]]></content>
  </entry>
  <entry>
    <title><![CDATA[【持续更新】Markdown笔记]]></title>
    <url>%2F2019%2F04%2F14%2FmarkdownCommand%2F</url>
    <content type="text"><![CDATA[Markdown 是一个 Web 上使用的文本到HTML的转换工具，可以通过简单、易读易写的文本格式生成结构化的HTML文档。 什么是MarkdownMarkdown 是一个 Web 上使用的文本到HTML的转换工具，可以通过简单、易读易写的文本格式生成结构化的HTML文档。目前 github、Stackoverflow 等网站均支持这种格式。 Markdown的优点最大好处是：快速掌握。 简单，适合所有人群，方便打开，不至于出现低版本word打不开高版本word的文档。 避免软件不同，如对方是wps，看到的word文档效果和你不一样。 方便快速排版，节省时间。 轻松的导出为HTML、PDF格式。 纯文本内容，兼容所有的文本编辑器与文字处理软件。 支持Markdown语法的编辑器有很多，部分网站也支持。 Markdown的工具Mac平台Mou：免费好用，支持实时预览，单文档，左边为编辑的Markdown语言，右边为预览效果。(注:Mac升级到sierra后Mou就不能使用了。据说开发者放弃了更新). MacDown: 与Mou相似,支持macOS Mojave. Web端简书,博客园,掘金 Markdown使用语法注意：所有符号均为英文输入法状态,示例图为:MacDown软件 标题设置 (#方法较方便)第一种方法：在标题文字前加#，一级标题为#，二级标题为##，三级标题为###，以此类推，最多六级，其中一级标题文字最大。 第二种方法：在标题文字下行输入–（符号前不可有空格），可表示二级标题。 在标题文字下行输入==，可表示一级标题。 引用块注释>在一段文字前表示引用,如下: 在一段文字前表示引用 文字*文字*斜体，**文字**加粗，“*”可用“_”代替，也能实现斜体和加粗。 文字间换行：在文字前输入 分割线你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线: 列表无序列表：文字前添加*或+或-和一个空格 有序列表：罗马数字和英文句号和一个空格 代码块和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 \ 和 \ 标签来把代码区块包起来。 要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以,示例如下: 超链接[我的博客](链接) 我的博客 Markdown的使用范围 邮件写作 写文章实现快速排版 印象笔记等软件记录笔记 小结简单总结了Markdown的常用语法,有什么问题欢迎留言.]]></content>
  </entry>
</search>
